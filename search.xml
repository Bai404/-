<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue生命周期笔记]]></title>
    <url>%2F2019%2F02%2F02%2FVUElifcircle%2F</url>
    <content type="text"><![CDATA[正在学习Vue生命周期，进行一下笔记整理，方便以后温习！ 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。vue 实例的生命周期钩子函数，可以把它理解为：vue实例在某一个时间点会自动执行的函数。 Vue 实例的生命周期函数（官方11个）： beforeCreate：在实例部分（事件/生命周期）初始化完成之后调用。 created：在完成外部的注入/双向的绑定等的初始化之后调用。 beforeMount：在页面渲染之前执行。 mounted：dom 元素在挂载到页面之后执行。 首次加载页面时，不会走下面这两个钩子，只有当数据发生改变时才会执行 beforeUpdate：数据改变，还没重新渲染之前执行。 updated：渲染数据完成之后执行。 执行销毁需要调用：vm.$destroy() beforeDestroy：实例销毁之前执行。 destroyed：实例销毁之后执行。 beforeCreate， created: 首先这是测试代码 12345678910111213 &lt;div id=&quot;app&quot;&gt;hello world&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, beforeCreate: function () &#123; console.log(&apos;beforeCreate&apos;); console.log(this.$el,this.$data); &#125;, created: function () &#123; console.log(&quot;created&quot;); console.log(this.$el,this.$data); &#125; &#125;) 控制台输出的结果为==beforeCreate==函数在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。==Created==函数在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。接着，我们往下看，如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。如果没有template选项，则将外部HTML作为模板编译。可以看到template中的模板优先级要高于outer HTML的优先级。在代码中添加template： 123456789101112var vm = new Vue(&#123; el: &quot;#app&quot;, template: &apos;&lt;div&gt;this is template&lt;/div&gt;&apos;, beforeCreate: function () &#123; console.log(&apos;beforeCreate&apos;); console.log(this.$el,this.$data); &#125;, created: function () &#123; console.log(&quot;created&quot;); console.log(this.$el,this.$data); &#125;&#125;) 在浏览器打开，可以看到template中的模板优先级要高于outer HTML的优先级。 beforeMouted， mounted:1234567891011121314151617181920212223var vm = new Vue(&#123; el: "#app", data: &#123; msg: 'hello world' &#125;, template: '&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', beforeCreate: function () &#123; console.log('beforeCreate'); console.log(this.$el,this.$data); &#125;, created: function () &#123; console.log("created"); console.log(this.$el,this.$data); &#125;, beforeMount: function () &#123; console.log("beforeMounted"); console.log(this.$el,this.$data); &#125;, mounted: function () &#123; console.log("mounted"); console.log(this.$el,this.$data); &#125;&#125;) ==beforeMount：== 在挂载开始之前被调用：相关的 render 函数首次被调用。==Mounted：== 123el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。结合这三个图可以看出在mounted之前div中还是通过进行占位的，因为此时挂到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到div中的内容发生了变化。 beforeUpdate，updated当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。我们先添加以下代码： 12345678beforeUpdate: function () &#123; console.log("beforeUpdate"); console.log(this.$el,this.msg,this.$data);&#125;,updated: function () &#123; console.log("updated"); console.log(this.$el,this.msg,this.$data);&#125; 然后再开控制台输入 vm.msg=’abc’ ==beforeUpdate：== 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。==updated：== 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 beforeDestroy和destroyed==beforeDestroy：== 实例销毁之前调用。在这一步，实例仍然完全可用。==destroyed：== Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP模式和MVVM模式学习笔记]]></title>
    <url>%2F2019%2F02%2F02%2FMVP%2F</url>
    <content type="text"><![CDATA[MVP模式模型-视图-表示器，也就是MVP模式。是mvc模式的一种衍生模式，专注于改进表示逻辑。 MModule，模型层，用户数据管理，通常是一些 javaBean, db,sharePreference,network,图片处理等耗时操作均应该放在该层。 VView，视图层,一般指的是四大组件，四大组件对作为View，来完成应用程序界面的展示 PPresenter 控制层，也叫中间层。相当于一个中间桥梁的作用，用于解决View 层与 Module 层的耦合，一般一个 Presenter 可以对应多个 View，一个Presenter 也可以对应多个Module MVP原理理解： 首先视图层V提交一个事件交给控制器P，控制器要么调用ajax去M中获取一些数据，要么根据业务逻辑直接去操作V的DOM。P层是MVP一个重要的位置，它是视图V和模型M的一个中转站。看一些例子可知，使用MVP模式的时候，控制器中大部分代码，其实都在操作dom。 关键点：View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有业务逻辑也有同步逻辑。View需要提供操作界面的接口给Presenter进行调用。（关键） MVVM模型-视图-视图模型是一种基于MVP的架构模式，它试图更清晰的将用户界面开发从应用程序的业务逻辑与行为中分离。 MModule，模型层，用户数据管理，通常是一些 javaBean, db,sharePreference,network,图片处理等耗时操作均应该放在该层。 VView，视图层,一般指的是四大组件，四大组件对作为View，来完成应用程序界面的展示 VMViewModule 控制层 ViewModule这里需要解释一下什么是ViewModel。ViewModel的含义就是 “Model of View”，视图的模型。它的含义包含了领域模型（Domain Model）和视图的状态（State）。 在图形界面应用程序当中，界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态是顺序的还是逆序的，而这是Domain Model所不包含的，但也是需要显示的信息。可以简单把ViewModel理解为页面上所显示内容的数据抽象，和Domain Model不一样，ViewModel更适合用来描述View。MVVM理解： MVVM模式中，我们更多做的V层和M层的操作，V能够监听到你V层上的改变，通过VM层去调用你写的一些逻辑代码，而这些逻辑代码的调用，又帮助你改变了M层的数据。当M层数据改变是，VM层又会自动把改变映射到V层。从MVVM模式中，我们的重点是M层的代码编写~ MVVM的优缺点 优点：提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。 缺点：过于简单的图形界面不适用，或说牛刀杀鸡。对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package control出现错误时怎样让sublime text3支持Vue语法高亮显示]]></title>
    <url>%2F2019%2F01%2F29%2Fpackage%20control%2F</url>
    <content type="text"><![CDATA[一般sublime按照vue插件步骤是： 安装Package Control Ctrl+Shift+P 执行Install Package 安装Vue Syntax Highlight可是我的package control出现了以下问题：There are no packages available for installation尝试辽各种解决方法！！还是没解决这个问题，如果有有能解决的帮帮窝，靴靴！！ 没办法。只能手动安装插件辽。 1.首先下载语法高亮插件vue-syntax-highlight。下载地址 https://github.com/vuejs/vue-syntax-highlight解开压缩包vue-syntax-highlight-master，其内所有文件备用。 2.将插件插入sublime 打开sublime的preferences—&gt;browse packages 在package文件夹下新建Vue文件夹 在Vue文件夹中，将vue-syntax-highlight-master压缩包解压后的所有文件考入。 3.sublime载入vue-syntax-highlight插件按下快捷键“ctrl+shift+p”，在打开的packages输入框中输入vue，选择“Set Syntax:Vue Component”进行加载。即可看到Vue文件高亮了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4学习笔记一]]></title>
    <url>%2F2019%2F01%2F29%2Fwebpack41%2F</url>
    <content type="text"><![CDATA[什么是WebpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 为什要使用WebPack现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法 模块化，让我们可以把复杂的程序细化为小的文件; 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别； Scss，less等CSS预处理器…这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。学习使用Webpack。创建一个bundle文件先创建一个用于学习的测试目录，初始化 npm， npm init -y使用npm init命令可以自动创建package.json文件,这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。 然后在本地安装webpack npm install –save-dev webpack太慢了 我推荐用淘宝镜像- -！！！cnpm ==因为使用的是webpack 4+ 版本，还需要安装 CLI。== npm install –save-dev webpack-cli 在我们的项目目录下，创建两个文件夹,src文件夹和dist文件夹，src文件夹用来存放原始数据和我们将写的JavaScript模块，dist文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。 然后在public文件夹中创建index.html，在app文件夹中创建index.js。 这个例子在index.js中使用lodash 依赖，我们需要在本地安装 library： npm install –save lodash index.js： 1234567import _ from 'lodash';function component()&#123; var element=document.createElement('div'); element.innerHTML=_.join(['hello','webpack',' ']); return element;&#125;document.body.appendChild(component()); index.js 显式要求引入的 lodash 必须存在，然后将它绑定为 _（没有全局作用域污染）。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。 index.html： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;webpack-demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行 npx webpack，会将我们的脚本作为入口起点，然后 输出 为 main.js。 运行index.html 使用一个配置文件在 webpack 4 中，可以无须任何配置使用，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 配置文件。我们创建webpack.config.jswebpack.config.js： 12345678910const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;;//“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 现在，让我们通过新配置文件再次执行构建：比起 CLI 这种简单直接的使用方式，配置文件具有更多的灵活性。我们可以通过配置方式指定 loader 规则(loader rules)、插件(plugins)、解析选项(resolve options)，以及许多其他增强功能。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现简单动态轮播（二）]]></title>
    <url>%2F2019%2F01%2F27%2FLunbo1%20(2)%2F</url>
    <content type="text"><![CDATA[效果图：先看布局的代码： 123456789101112&lt;div class="banner"&gt; &lt;ul class="clear" style="left:-100%;" &gt; &lt;li&gt;&lt;img src="yy.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="3.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="5.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="yy.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="3.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="pageNav"&gt;&lt;/div&gt; &lt;div class="leftBtn"&gt;&lt;/div&gt; &lt;div class="rightBtn"&gt;&lt;/div&gt;&lt;/div&gt; 可以看出这个轮播和我的前一篇轮播，布局的思路稍微不同。无缝轮播只放需要的图片，轮播时所看到的两张图片的left都改变。而这个轮播是把ul的宽设为所有图片加起来的长度，轮播时移动ul的left，并在第一张图片前放置最后一张图片，最后一张图片后放置第一张图片。 布局大体也一样，就是重点便是ul设置为500%。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.clear:after&#123; display:block; content:""; clear:both;&#125;.banner&#123; position:relative; width: 100%; height: 500px; overflow:hidden;&#125;.banner ul&#123; list-style-type:none; position:relative; width: 500%; height: 500px;&#125;.banner ul li&#123; float: left; width: 20%;&#125;.pageNav&#123; position: absolute; left:50%; bottom:20px; transform: translateX(-50%);&#125;.pageNav a&#123; display:inline-block; margin:0 5px; width: 20px; height: 20px; background-color:#fff; border-radius:50%; border:2px solid #000; cursor:pointer;&#125;.pageNav a.cur&#123; background-color:red;&#125;.leftBtn, .rightBtn&#123; position:absolute; top: 50%; transform:translateY(-50%); width: 40px; height: 50px; background-color:rgba(0, 0, 0, 0.5); cursor:pointer;&#125;.leftBtn&#123; left:0;&#125;.rightBtn&#123; right:0;&#125;.leftBtn:hover,.rightBtn:hover&#123; background-color:rgba(0, 0, 0, 0.8);&#125; 接下来是js部分，思路也很相似，移动的元素不一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//先获取所需要的dom元素var banner=document.getElementsByClassName("banner")[0], ul=banner.getElementsByTagName("ul");[0]var li=ul.getElementsByTagName("li");var pageNav=banner.getElementsByClassName("pageNav")[0];var leftBtn=banner.getElementsByClassName("leftBtn")[0],rightBtn=banner.getElementsByClassName("rightBtn")[0]; var n=0,timerElem,animate=false;//添加分页按钮 for(var i=0;i&lt;li.length-2;i++)&#123; var pageA=document.createElement("a"); if(i==0)&#123; pageA.className="cur"; &#125; pageNav.appendChild(pageA); &#125; pageNav.addEventListener('click',pageNavClick,false); function pageNavClick(e)&#123; e=e||window.event;//兼容性考虑 for(var j=0;j&lt;li.length-2;j++)&#123; if(pageNav.children[j]==e.target)&#123; var offset=(j-n)*(-100); btnShow(j); n=j; showImg(offset); &#125; &#125; &#125; //分页按钮函数 function btnShow(index)&#123; for(var a=0;a&lt;li.length-2;a++)&#123; pageNav.children[a].className=""; &#125; pageNav.children[index].className="cur"; &#125; function showImg(offset)&#123; clearInterval(timerElem);//记得清除计时器，要不然多个计时器叠加，效果会出现问题。 var speed=offset/20; var newLeft=parseInt(ul.style.left)+offset; timerElem=setInterval(function()&#123; if(parseInt(ul.style.left)==newLeft)&#123; clearInterval(timerElem); // 当第三张开始滑动时，屏幕接着它滑动的是放置在它后面的假的第一张，所以滑动结束之后要把位置从转回真的第一张 if(n==0)&#123; ul.style.left="-100%"; &#125;else if(n==li.length-3)&#123; ul.style.left=(-100)*(li.length-2)+"%"; &#125;else&#123; ul.style.left=newLeft+"%"; &#125; animate=false; &#125; else&#123; animate=true; ul.style.left=parseInt(ul.style.left)+speed+"%"; &#125; &#125;,50) &#125; rightBtn.onclick=function()&#123; if(animate)&#123; return; &#125; n++; if(n&gt;=li.length-2)&#123; n=0; &#125; btnShow(n); showImg(-100); &#125; leftBtn.onclick=function()&#123; if(animate)&#123; return; &#125; n--; if(n&lt;0)&#123; n=li.length-3; &#125; btnShow(n); showImg(-100); &#125; var timer=setInterval(autoLunbo,3000); function autoLunbo()&#123; rightBtn.onclick(); &#125; banner.onmouseover=function()&#123; clearInterval(timer); &#125; banner.onmouseout=function()&#123; timer=setInterval(autoLunbo,3000); &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现动态轮播（一）无缝轮播]]></title>
    <url>%2F2019%2F01%2F23%2FLunbo%2F</url>
    <content type="text"><![CDATA[在同学的帮助下，终于使用纯js代码实现了动态轮播，好难啊呜呜呜！学无止境加油吧！ 效果图是这样的，我们需要定义一个div，并放入三张图片，还需要左右两个按钮，以及底下三个按钮三个div。先看布局代码 12345678910&lt;div class="banner" id="banner"&gt; &lt;ul class="clear" &gt; &lt;li style="left:0" &gt;&lt;img src="k1.jpg"&gt;&lt;/li&gt; &lt;li style="left:100%" &gt;&lt;img src="k-2.jpg"&gt;&lt;/li&gt; &lt;li style="left:100%"&gt;&lt;img src="k-3.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="pageNav"&gt;&lt;/div&gt; &lt;div class="leftBtn"&gt;&lt;/div&gt; &lt;div class="rightBtn"&gt;&lt;/div&gt;&lt;/div&gt; 如何是css部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.clear:after&#123; display:block; content:""; clear:both;&#125;.banner&#123; width: 100%; position:relative; height: 390px;&#125;.banner ul&#123; width: 100%; height: 390px; list-style-type:none; overflow: hidden;&#125;.banner ul li&#123; width: 100%; position: absolute;&#125;.pageNav&#123; position: absolute; left:50%; bottom:20px; transform: translateX(-50%);&#125;.pageNav a&#123; display:inline-block; margin:0 5px; width: 20px; height: 20px; background-color:#fff; border-radius:50%; border:2px solid #000; cursor:pointer;&#125;.pageNav a.cur&#123; background-color:red;&#125;.leftBtn, .rightBtn&#123; position:absolute; top: 50%; transform:translateY(-50%); width: 40px; height: 50px; background-color:rgba(0, 0, 0, 0.5); cursor:pointer;&#125;.leftBtn&#123; left:0;&#125;.rightBtn&#123; right:0;&#125;.leftBtn:hover,.rightBtn:hover&#123; background-color:rgba(0, 0, 0, 0.8);&#125; 接下来是js部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var banner=document.getElementById("banner"); var ul=banner.getElementsByTagName("ul")[0]; var li=ul.getElementsByTagName("li"); var pageNav=banner.getElementsByClassName("pageNav")[0],leftBtn=document.getElementsByClassName("leftBtn")[0],rightBtn=document.getElementsByClassName("rightBtn")[0],n=0,index=0,timerElem=null,state=false; for(var i=0;i&lt;li.length;i++)&#123;//给图片底下添加按钮 pageA=document.createElement("a"); if(i==0)&#123; pageA.className="cur"; &#125; pageNav.appendChild(pageA); &#125; pageNav.addEventListener('click',pageNavClick,false); function pageNavClick(e)&#123; if(state)&#123; return; &#125; e=e||window.event;//兼容性考虑 for(var i=0;i&lt;li.length;i++)&#123; if(pageNav.children[i]==e.target)&#123; index=n; var offset=i-n; n=i; showBtn(n); if(offset&gt;0)&#123; showImg(-100); &#125;else&#123; showImg(100); &#125; &#125; &#125; &#125; function showBtn(index)&#123; for(var z=0;z&lt;li.length;z++)&#123; pageNav.children[z].className=""; &#125; pageNav.children[index].className="cur"; &#125; function showImg(offset)&#123; clearInterval(timerElem); var speed=offset/20; timerElem=setInterval(function()&#123; state=true; if(parseInt(li[n].style.left)==0)&#123; state=false; clearInterval(timerElem); li[n].style.left="0"; for(var l=0;l&lt;n;l++)&#123; li[l].style.left="-100%" &#125; for(var r=n+1;r&lt;li.length;r++)&#123; li[r].style.left="100%"; &#125; &#125;else&#123; li[n].style.left=parseInt(li[n].style.left)+speed+"%"; li[index].style.left=parseInt(li[index].style.left)+speed+"%"; &#125; &#125;,100) &#125; leftBtn.onclick=function()&#123; if(state)&#123; return; &#125; index=n; n--; if(n&lt;0)&#123; n=li.length-1; li[n].style.left="-100%"; &#125; showBtn(n); showImg(100); &#125; rightBtn.onclick=function()&#123; if(state)&#123; return; &#125; index=n; n++; if(n&gt;li.length- 1)&#123; n=0; li[n].style.left="100%"; &#125; showBtn(n); showImg(-100); &#125; var timer; timer=setInterval(autoLunbo,3000); function autoLunbo()&#123; rightBtn.onclick(); &#125; banner.onmouseover=function()&#123; clearInterval(timer); &#125; banner.onmouseout=function()&#123; timer=setInterval(autoLunbo,3000); &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式学习笔记]]></title>
    <url>%2F2019%2F01%2F21%2FsingleEg%2F</url>
    <content type="text"><![CDATA[今天的学习jquery组件开发时候例子使用了单例模式，所以总结了一些相关知识。 单例模式介绍首先什么是单例模式？可以这样理解：单例模式旨在保证一个类仅有一个实例，并提供一个全局的访问点。可能有人还是不太理解单例的概念，那么你可以想象生活中的一些例子。比如注册账号的时候，如果我们注册的账号已经存在，那么系统会提示我们“账号已经存在是否使用该账号登陆”，我们无法再次创建一个一模一样的账号，除非把原账号注销。这就是单例模式的生动体现。 单例模式的思路 一个类能返回一个对象的引用（并且永远是同一个）和一个获得该实例的方法（静态方法，通常使用 getInstance 名称）。那么当我们调用这个方法时，如果类持有的引用不为空就返回该引用，否者就创建该类的实例，并且将实例引用赋值给该类保持的那个引用再返回。同时将该类的构造函数定义为私有方法，避免其他函数使用该构造函数来实例化对象，只通过该类的静态方法来得到该类的唯一实例。 介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个党只能有一个书记。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 命名空间例如jQuery库的命名空间为jQuery或$。命名空间的使用是为了让代码更加整洁，在多人协作开发的情况下，不同的人定义的变量很有可能重复，此时就需要使用命名空间来约束每个人定义的变量，使相同名称的变量放在不同的命名空间中，避免相互干扰。 123456789101112131415161718// A程序员的命名空间var A = &#123; get: function(id)&#123; return document.getElementById(id); &#125; css: function(id,key,value)&#123; get(id).style[key] = value; &#125;&#125;// B程序员的命名空间var B = &#123; get: function(className)&#123; return document.getElementByClassName(className)[0]; &#125; css: function(className,key,value)&#123; get(className).style[key] = value; &#125;&#125; A、 B两个命名空间中都有一个get方法和一个css方法，用于元素获取和元素样式修改，不同的是A是通过id来获取元素，而B是通过class来获取元素，通过命名空间，可以使这些相同名称的方法共存，使用时指定相应的命名空间即可。 常量JavaScript中并没有final、static这类关键字用来定义常量，但JavaScript非常灵活，通过常量只能访问不能修改这一特点，我们可以将变量保存在函数内部，并且只提供获取变量的方法，不提供设置变量的方法，通过闭包的方式使函数执行一次并返回相应的访问方法对象，最后将这个对象放在全局空间中作为常量单例对象使用。例如： 123456789101112131415161718var Color = (function()&#123; // 私有变量 var color = &#123; &apos;RED&apos;: &apos;#ff0000&apos;, &apos;YELLOW&apos;: &apos;#ffff00&apos;, &apos;BLUE&apos;: &apos;#0000ff&apos; &#125; // 返回访问方法对象 return &#123; // 常量获取方法 get: function(name)&#123; return color[name] ? color[name] : null; &#125; &#125;&#125;)();var color = Color.get(&apos;BLUE&apos;);console.log(color); // #0000ff 实现方式实现1： 最简单的对象字面量1234567var singleton = &#123; attr : 1, method : function()&#123; return this.attr; &#125; &#125;var t1 = singleton ;var t2 = singleton ; 那么很显然的， t1 === t2 。 十分简单，并且非常使用，不足之处在于没有什么封装性，所有的属性方法都是暴露的。对于一些需要使用私有变量的情况就显得心有余而力不足了。当然在对于 this 的问题上也是有一定弊端的。 实现2：构造函数内部判断 其实和最初的JS实现有点类似，不过是将对是否已经存在该类的实例的判断放入构造函数内部。12345678910111213function Construct()&#123; // 确保只有单例 if( Construct.unique !== undefined )&#123; return Construct.unique; &#125; // 其他代码 this.name = &quot;NYF&quot;; this.age=&quot;24&quot;; Construct.unique = this;&#125;var t1 = new Construct() ;var t2 = new Construct() ; 那么也有的， t1 === t2 。 也是非常简单，无非就是提出一个属性来做判断，但是该方式也没有安全性，一旦我在外部修改了Construct的unique属性，那么单例模式也就被破坏了。 实现3 : 闭包方式12345678var single = (function()&#123; var unique; function Construct()&#123; // ... 生成单例的构造函数的代码 &#125; unique = new Constuct(); return unique;&#125;)(); 只要每次将var t1 = single; var t2 = single;即可。 与对象字面量方式类似。不过相对而言更安全一点，当然也不是绝对安全。 如果希望会用调用 single() 方式来使用，那么也只需要将内部的 return 改为 return function(){ return unique; } 以上方式也可以使用 new 的方式来进行（形式主义的赶脚）。当然这边只是给了闭包的一种例子而已，也可以在 Construct 中判断单例是否存在 等等。 各种方式在各个不同情况做好选着即可。 使用数据缓存来存储该单例，用作判断单例是否已经生成，是单例模式主要的实现思路。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS购物网站商品放大镜功能]]></title>
    <url>%2F2019%2F01%2F14%2Fzoom%2F</url>
    <content type="text"><![CDATA[首先看效果图：先是布局，左边一个小图框，包含一个鼠标移动框，右边一个放大框。 123456789&lt;div class="box"&gt; &lt;div class="small"&gt; &lt;img src="small3.jpg" alt=""&gt; &lt;div class="move"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="big"&gt; &lt;img src="big3.jpg" alt=""&gt; &lt;/div&gt;&lt;/div&gt; 写一下css 12345678910111213141516171819202122232425262728293031.small&#123; position: relative; float: left; width: 450px; height: 450px; border:1px solid #000;&#125;.small .move&#123; position: absolute; top:0; width: 300px; height: 300px; background-color: rgba(0,0,0,0.4); cursor:move; display: none;&#125;.big&#123; position: relative; float: left; width: 540px; height: 540px; margin-left: 20px; overflow: hidden; border:1px solid #000; display: none;&#125;.big img&#123; position: absolute; top:0; left: 0;&#125; js部分： 1234567891011121314151617181920212223242526272829303132333435var box=document.getElementsByClassName('box')[0],small=box.getElementsByClassName('small')[0],move=small.getElementsByClassName('move')[0],smallImg=small.getElementsByTagName('img')[0],big=box.getElementsByClassName('big')[0],bigImg=big.getElementsByTagName('img')[0];//首先把需要的元素都获取出来small.onmouseover=function()&#123; move.style.display='block'; big.style.display="block";&#125;;small.onmouseout=function()&#123; move.style.display='none'; big.style.display="none";&#125;;small.onmousemove=function(e)&#123; e=e||window.event;//兼容性考虑 var x=e.clientX-smallImg.getBoundingClientRect().left-move.offsetWidth/2; var y=e.clientY-smallImg.getBoundingClientRect().top-move.offsetHeight/2; if(x&lt;0)&#123; x=0; &#125; if(x&gt;smallImg.offsetWidth-move.offsetWidth)&#123; x=smallImg.offsetWidth-move.offsetWidth; &#125; if(y&lt;0)&#123; y=0; &#125; if(y&gt;smallImg.offsetHeight-move.offsetHeight)&#123; y=smallImg.offsetHeight-move.offsetHeight; &#125; move.style.left=x+"px"; move.style.top=y+"px"; //实现左边move块跟随鼠标移动的代码 var scale=bigImg.offsetWidth/smallImg.offsetWidth; //按照比例放大 bigImg.style.left='-'+x*scale+'px'; //因为图片是需要左移和上移的所以要加负号 bigImg.style.top='-'+y*scale+'px';&#125; 放大镜效果就实现啦！]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery $.extend()使用方法总结]]></title>
    <url>%2F2019%2F01%2F14%2FjQuery-extend()%2F</url>
    <content type="text"><![CDATA[extend能实现的功能将一个或多个对象的内容合并到目标对象。语法： $.extend( target [, object1 ] [, objectN ] )；$.extend( [deep ], target, object1 [, objectN ] ) deep： 可选。 Boolean类型 指示是否深度合并对象，默认为false。如果该值为true，且多个对象的某个同名属性也都是对象，则该”属性对象”的属性也将进行合并。 target： Object类型 目标对象，其他对象的成员属性将被附加到该对象上。 object1：可选。 Object类型 第一个被合并的对象。 objectN：可选。 Object类型 第N个被合并的对象。注意： 如果只为$.extend()指定了一个参数，则意味着参数target被省略。此时，target就是jQuery对象本身。通过这种方式，我们可以为全局对象jQuery添加新的函数。 如果多个对象具有相同的属性，则后者会覆盖前者的属性值。 举例： $.extend(object1, object2); //object2 合并到 object1 中 多传几个参数： 123456789101112131415161718192021function test(target,obj1,obj2,obj3)&#123; $.extend(target,obj1,obj2,obj3); return target;&#125;;var target=&#123; name:&apos;jack&apos;, sex:&apos;male&apos;&#125;;var obj1=&#123; name:&quot;rose&quot;, age:20&#125;;var obj2=&#123; sex:&apos;female&apos;, age:24&#125;;var obj3=&#123; bb:&apos;you jump i jump&apos;&#125;;console.log(test(target,obj1,obj2,obj3));//Object &#123; name: &quot;rose&quot;, sex: &quot;female&quot;, age: 24, bb: &quot;you jump i jump&quot; &#125; 这里我们传入了4个参数，然后返回第一个参数的值。从运行的得到结果我们可以看到，属性值永远是最后一个属性的值。我们稍微修改一部分代码： 123 var res=$.extend(target,obj1,obj2,obj3); return res;结果返回依然是Object &#123; name: &quot;rose&quot;, sex: &quot;female&quot;, age: 24, bb: &quot;you jump i jump&quot; &#125; 所以$.extend()的返回值是第一个参数的值。如果我们不想修改参数的值，我们可以把传入一个空对象： $.extend({ },target,obj1,obj2,obj3); 为jQuery开发插件提供方法如果只有一个参数提供给$.extend()，在这种情况下，jQuery对象本身被默认为目标对象。这样，我们可以在jQuery的命名空间下添加新的功能。这对于插件开发者希望向 jQuery 中添加新函数时是很有用的。 jQuery.extend(object)： 为jQuery类本身添加类方法，可以理解为添加静态方法。 12345678$.extend(&#123; hello:function()&#123; return &quot;hello&quot;+this._name; &#125;, _name:&apos;jack&apos;&#125;)console.log($._name,$.hello());//jack hellojack jQuery.fn.extend(object);给jQuery对象添加方法。。jQuery类的实例才可以调用这个“成员函数”。为什么呢我们先看： 1234jQuery.fn = jQuery.prototype = &#123; init: function( selector, context ) &#123;//….//……&#125;; ．ｆｎ属性是在原型上的，所以只有实例化出来的jQuery可以调用你ｅｘｔｅｎｄ里想添加的方法。 比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做： 123456789$.fn.extend(&#123; alertWhileClick: function() &#123; $(this).click(function() &#123; alert($(this).val()); &#125;); &#125;&#125;);//$(&quot;#input1&quot;)是jQuery的实例，调用这个扩展方法$(&quot;#input1&quot;).alertWhileClick();]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现抽奖大转盘]]></title>
    <url>%2F2019%2F01%2F11%2Fstar_js%2F</url>
    <content type="text"><![CDATA[因为用到自定义字体，我首先到阿里巴巴矢量图标库下载了自己喜欢的星星样式。需要一个空心星星，一个实心星星。 按照使用方法，如下图所示引入这些文件。 接下来是布局，三行评价，都是一样的样式，那就用一个无序列表吧！ 1234567891011121314151617181920212223242526272829&lt;ul&gt; &lt;li class="goods"&gt; 宝贝与描述相符： &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;/li&gt; &lt;li class="att"&gt; 卖家的服务态度： &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;/li&gt; &lt;li class="trans"&gt; 物流服务的质量： &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;/li&gt;&lt;/ul&gt; 给star类加了一个伪类用来显示星星图标： 12345678910111213141516 .star:after&#123; font-family: 'Hui-iconfont'; font-size:25px; font-style:normal; content:"\e702"; vertical-align:middle;/*使文字和图标对齐*/ color:#eee; &#125;下面这是实心星星的： .current:after&#123; font-family: 'Hui-iconfont'; font-size:25px; font-style:normal; content:"\e6ff"; vertical-align:middle; &#125; 布局完是这样的：下面开始写js. 1234567891011121314151617181920212223242526272829303132333435363738function comment(liName,content)&#123; var li=document.getElementsByClassName(liName)[0]; var star=li.getElementsByTagName("i"); var currentClick=0,num=0; for(var i=1;i&lt;=star.length;i++)&#123; star[i-1].index=i; star[i-1].onmouseover=function()&#123; show(this.index); &#125; star[i-1].onmouseout=function()&#123; //选择i=1；就是为了把0让给这一步，鼠标移开不显示实星星。 show(0); &#125; star[i-1].onclick=function()&#123; currentClick=this.index; show(currentClick); &#125; &#125; function show(index)&#123; //当点击后，又经过又离开，传递参数0；但短路语句直接返回currentClick,以此保证点击之后再经过也不改变。 num=index||currentClick; for(var j=0;j&lt;star.length;j++)&#123; star[j].className=(j&lt;num)?'current':'star'; if(num==1||num==2)&#123; star[j].style.color="#666" &#125; else if(num==3||num==4)&#123; star[j].style.color="orange"; &#125; else&#123; star[j].style.color="red"; &#125; &#125; li.getElementsByTagName("em")[0].innerText=num&gt;0?content[num-1]:""; &#125;&#125;var arr=["一分 失望","两分 不满","三分 一般","四分 满意","五分 惊喜"];comment("goods",arr);comment("att",arr);comment("trans",arr) 就可以实现基本的效果啦！]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础之Dom篇总结]]></title>
    <url>%2F2019%2F01%2F08%2FjQuery_Dom%2F</url>
    <content type="text"><![CDATA[dom小知识点很多，总是过段时间又忘了，这次做个总结吧。 Dom节点的创建jQuery节点创建常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来。创建元素节点： 1234567$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)创建文本节点：$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;)创建属性节点：$(&quot;&lt;div id=&apos;test&apos; class=&apos;aaron&apos;&gt;我是文本节点&lt;/div&gt;&quot;) Dom节点的插入内部插入.append()前面是被插入的对象，后面是要在对象内插入的元素内容.appendTo()前面是要插入的元素内容，而后面是被插入的对象.prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素.prependTo()方法前面是要插入的元素内容，后面是被插入的对象，插到之前。1234567891011121314 例子 &lt;h2&gt;通过append与appendTo添加元素&lt;/h2&gt; &lt;button id="btn1"&gt;点击通过jQuery的append添加元素&lt;/button&gt; &lt;button id="btn2"&gt;点击通过jQuery的appendTo添加元素&lt;/button&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;script&gt; $("#btn1").on('click',function()&#123; $('.content').append($('&lt;div class="append"&gt;通过append方法添加的元素&lt;/div&gt;')) // $('.content').prepend($('&lt;p&gt;prepend方法插入的元素！在前面哦！&lt;/p&gt;')) &#125;) $('#btn2').on('click',function()&#123; $('&lt;div class="appendTo"&gt;通过appendTo方法添加的元素&lt;/div&gt;').appendTo($('.content')) &#125;)&lt;/script&gt; 外部插入.before():在选中元素后插入参数所指定的内容，作为其兄弟节点.after():在选中元素前插入参数所指定的内容，作为其兄弟节点 before与after都是用来对相对选中元素外部增加相邻的兄弟节点2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面2个方法都支持多个参数传递after(div1,div2,….) insertAfter()与insertBefore()insertBefore()和before的效果是一样的，只不过使用方式不一样。insertBefore():插入的内容在前，括号里是要插入的节点。不支持多参数！ 123456789101112131415例子&lt;h2&gt;通过insertBefore与insertAfter添加元素&lt;/h2&gt; &lt;button id="bt1"&gt;点击通过jQuery的insertBefore添加元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的insertAfter添加元素&lt;/button&gt; &lt;div class="aaron"&gt; &lt;p class="test1"&gt;测试insertBefore,不支持多参数&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p class="test2"&gt;测试insertAfter,不支持多参数&lt;/p&gt; &lt;/div&gt;&lt;script&gt; $('#bt1').on('click',function()&#123; $('&lt;p style="color:red"&gt;测试insertBefore方法增加&lt;/p&gt;', '&lt;p style="color:red"&gt;多参数&lt;/p&gt;').insertBefore($(".test1")); &#125;)&lt;/script&gt; Dom节点的删除empty():顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了指定元素中的所有子节点。 remove()会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。remove可以传递一个选择器表达式用来过滤匹配元素，可以选择性的删除指定的节点 例如： 123$(&quot;p&quot;).remove(&quot;:contains(&apos;3&apos;)&quot;) 移除所有元素中包含3文本的 此代码也可以写为： $(&quot;p&quot;).filter(&quot;:contains(&apos;3&apos;)&quot;).remove() 保留数据的删除操作detach()： 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。 $(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据。 Dom节点的复制与替换 clone（）：.clone() 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。.clone()是浅拷贝。 .clone(true)是深拷贝。复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。.clone()是浅拷贝。 .clone(true)是深拷贝。 replaceWith(), .replaceAll( target ):.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合.replaceAll( target ) ：用集合的匹配元素替换每个目标元素.replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序.replaceWith（）方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用。返回的是Jquery对象引用的是替换前的节点。 wrap()方法:.wrap( wrappingElement )：在集合中匹配的每个元素周围包裹.wrap( function ) ：一个回调函数，返回用于包裹匹配元素的HTML 内容或 jQuery 对象。 unwrap()方法:作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。 wrapAll()方法:wrap是针对单个dom元素处理，如果要将集合中的元素用其他元素包裹起来，也就是给他们增加一个父元素，针对这样的处理，JQuery提供了一个wrapAll方法.wrapAll( wrappingElement )：给集合中匹配的元素增加一个外面包裹HTML结构.wrapAll( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。 .wrapInner( wrappingElement )：.wrapInner( wrappingElement )： 给集合中匹配的元素的内部，增加包裹的HTML结构给集合中匹配的元素的内部，增加包裹的HTML结构将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素。.wrapInner( function ) ：允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容注意： 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。遍历后代：children() 方法返回被选元素的所有直接子元素。该方法只会向下一级对DOM 树进行遍历。.children()方法选择性地接受同一类型选择器表达式例如：$(“div”).children(“.selected”)因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签)。例子： 12var $spans = $(&apos;span&apos;);$(&quot;p&quot;).find($spans).css(&apos;color&apos;, &apos;red&apos;); 祖先：parent() 方法返回被选元素的直接父元素。该方法只会向上一级对 DOM 树进行遍历。 parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。可以使用可选参数来过滤对祖先元素的搜索。 parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。 closest()：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素树上逐级向上级元素匹配，并返回最先匹配的祖先元素。$(“div”).closet(“li’) 在div元素中往上查找所有的li元素 .parents()和.closest()的区别： 1.起始位置不同：.closest开始于当前元素 .parents开始于父元素 2.遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 3.结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 同胞：next() 方法返回被选元素的下一个同胞元素。该方法只返回一个元素。选择性地接受同一类型选择器表达式prev() 查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合.选择性地接受同一类型选择器表达式nextAll() 返回被选元素的所有跟随的同胞元素。nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。siblings() 方法返回被选元素的所有同胞元素。选择性地接受同一类型选择器表达式 add():将元素添加到匹配的元素集合中，.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。 123456each()： $(&quot;li&quot;).each(function(index, element) &#123; index 索引 0,1 element是对应的li节点 li,li this 指向的是li &#125;) each是一个for循环的包装迭代器 each通过回调的方式处理，并且会有2个固定的实参，索引与元素 each回调方法中的this指向当前迭代的dom元素例子： 12345678910111213141516 &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;p&gt;6&lt;/p&gt;&lt;script&gt; $('p').each(function(index,ele)&#123; $(this).css('color','red'); &#125;); $('p').each(function(index,ele)&#123; if(index %2)&#123; $(this).css('color','blue'); &#125;; &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是SDK什么是CDN]]></title>
    <url>%2F2019%2F01%2F07%2FCDN%2F</url>
    <content type="text"><![CDATA[今天的学习过程中碰到了Sdk，cdn，关于它们一直没有清楚的概念。好吧对于我来说要了解好CDN得花点功夫了- -！不懂不要紧，加油学吧！ 什么是SDK软件开发工具包（Software Development Kit，即SDK）一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。 软件开发工具包，只是简单的为某个程序设计语言提供应用程序接口的一些文件，但也可能包括能与某种嵌入式系统通讯的复杂的硬件。 SDK通常包含许可证，这些许可证使它们不适合构建旨在根据不兼容许可证开发的软件。例如，专有SDK通常与自由软件开发不兼容，而GPL许可的SDK可能与专有软件开发不兼容，所有这些都特别是出于法律原因。但是，根据GNU宽通用公共许可证（LGPL）构建的SDK通常对于专有开发是安全的。 SDK是一系列程序接口，文档，开发工具的集合。sdk即单单不是一个开发工具，也不是一个程序。一个完整的SDK应该包括以下内容： （1）接口文件和库文件接口文件和库文件就是API，将底层的代码进行封装保护，提供给用户一个调用底层代码的接口； （2）帮助文档帮助文档解释接口文件和库文件功能，以及介绍相关的开发工具，操作示例等等； （3）开发示例开发示例就是做出来的一个DEMO展示，也要包括源代码； （4）实用工具。 实用工具是用来协助用户进行二次开发的工具，比如二次开发向导、API 搜索工具、软件打包工具等。 CDN什么是CDNCDN的全称是Content Delivery Network，即内容分发网络。 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 基本原理CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 使用CDN的好处CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。因此，有如下优点： 通过提高网站响应速度，改善用户体验，增强用户满意度和粘合度; 轻松应对突发流量，随时展开网络推广; 有效抵御洪水式网络攻击，使网站永不宕机; 减少源站点负载，节省网站分布式架构的支出成本和运维成本。 基础架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成： 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。 CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。 用户向CDN的全局负载均衡设备发起内容URL访问请求。 CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。 全局负载均衡设备把服务器的IP地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。哪些情况推荐使用CDN？一般来说以资讯、内容等为主的网站，具有一定访问体量的网站资讯网站、政府机构网站、行业平台网站、商城等以动态内容为主的网站论坛、博客、交友、SNS、网络游戏、搜索/查询、金融等。提供http下载的网站软件开发商、内容服务提供商、网络游戏运行商、源码下载等有大量流媒体点播应用的网站拥有视频点播平台的电信运营商、内容服务提供商、体育频道、宽频频道、在线教育、视频博客等这个大神关于CDN的解释真的很通俗易懂！侵权删！ https://www.zhihu.com/question/36514327]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>sdk</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高级之运动系列（匀速运动/缓冲运动/弹性运动）]]></title>
    <url>%2F2019%2F01%2F06%2FJS_moves%2F</url>
    <content type="text"><![CDATA[匀速运动鼠标经过，匀速运动开始css部分12345678910111213141516171819202122232425*&#123; margin: 0; padding: 0;&#125;.box&#123; position:relative; width:150px; height:150px; background-color: green; top:300px; left:-150px;&#125;.box span&#123; position:absolute; right:-20px; display:block; width:20px; background-color: red; top:50%; -webkit-transform: translateY(-50%); -moz-transform: translateY(-50%); -ms-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 布局123&lt;div class="box"&gt; &lt;span&gt;匀速&lt;/span&gt;&lt;/div&gt; js代码12345678910111213141516171819202122232425262728window.onload=function()&#123; var box=document.getElementsByClassName("box")[0]; box.onmouseover=function()&#123; startMove(box,0); &#125; box.onmouseout=function()&#123; startMove(box,-150); &#125;&#125;var timer=null;function startMove(obj,target)&#123; var speed=0; clearInterval(timer); timer=setInterval(function()&#123; if(obj.offsetLeft&lt;target)&#123; speed=10; &#125;else&#123; speed=-10; &#125; if(obj.offsetLeft==target)&#123; clearInterval(timer); &#125;else&#123; obj.style.left=obj.offsetLeft+speed+"px"; &#125; &#125;,30);&#125; 简单缓冲运动并回到原点布局部分，嘿嘿以简单为主。1234&lt;div class="box"&gt;&lt;/div&gt;&lt;input type="button" name="" value="开始"&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;input type="button" name="" value="回到原点"&gt; css部分12345678910111213141516171819body&#123; padding: 0; margin: 0;&#125;.box&#123; position:absolute; top:40px; width: 100px; height: 100px; background-color:red;&#125;.line&#123; position:absolute; left:700px; top:0; width: 5px; height: 200px; background-color:#000;&#125; js代码12345678910111213141516171819202122232425262728293031323334353637var btn=document.getElementsByTagName("input")[0]; var box=document.getElementsByClassName("box")[0]; var back=document.getElementsByTagName("input")[1]; window.onload=function()&#123; var timer=null; btn.onclick=function()&#123; startMove(box,700); &#125; //缓冲运动部分 function startMove(elem,target)&#123; clearTimeout(timer); timer=setInterval(function()&#123; var speed=(target-elem.offsetLeft)/10; speed=speed&gt;0?Math.ceil((target-elem.offsetLeft)/10):Math.floor((target-elem.offsetLeft)/10); if(target==elem.offsetLeft)&#123; clearTimeout(timer); &#125;else&#123; elem.style.left=elem.offsetLeft+speed+"px"; &#125; &#125;,100) &#125; back.onclick=function()&#123; startMove(box,0); &#125; //回到原点部分 function backMove(elem,target)&#123; clearTimeout(timer); timer=setInterval(function()&#123; var speed=Math.floor((target-elem.offsetLeft)/10); if(target==elem.offsetLeft)&#123; clearTimeout(timer); &#125;else&#123; elem.style.left=elem.offsetLeft+speed+"px"; &#125; &#125;,100) &#125; &#125; 弹性运动一个运动的盒子，一个开始的按钮，一条终点线.，我设置这条线的原因是方便看出效果，也可以不设啦。123&lt;div class="box"&gt;&lt;/div&gt;&lt;input type="button" name="" value="开始"&gt;&lt;div class="line"&gt;&lt;/div&gt; javaScript代码如下：12345678910111213141516171819202122window.onload=function()&#123; var btn=document.getElementsByTagName("input")[0]; var box=document.getElementsByClassName("box")[0]; btn.onclick=function()&#123; startMove(box,700); &#125; var timer=null; function startMove(elem,target)&#123; var speed=0; timer=setInterval(function()&#123; speed+=(target-elem.offsetLeft)/8; speed*=0.7; //我觉得0.7的效果好一点 if(Math.abs(speed)&lt;1&amp;&amp;Math.abs(elem.offsetLeft-target)&lt;1)&#123; clearTimeout(timer); elem.style.left=target+"px";//回到终点位置 &#125;else&#123; elem.style.left=elem.offsetLeft+speed+"px"; &#125; &#125;,100) &#125; &#125; 为了使刚好在终点线的位置做弹性运动，传入参数target就是终点线距离盒子的位置。css部分123456789101112131415.box&#123; position:absolute; top:40px; width: 100px; height: 100px; background-color:red;&#125;.line&#123; position:absolute; left:700px; top:0; width: 5px; height: 200px; background-color:#000;&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习镜像概念]]></title>
    <url>%2F2019%2F01%2F06%2FMirroring%2F</url>
    <content type="text"><![CDATA[在自学Node.js过程中，看到有说国内直接使用 npm 的官方镜像是非常慢的，推荐使用淘宝 NPM 镜像。由于是半路出家没有很好的计算机基础知识，并不清楚镜像的概念。镜像（Mirroring）是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。镜像是一种文件存储形式，可以把许多文件做成一个镜像文件。所谓镜像文件其实和ZIP压缩包类似，它将特定的一系列文件按照一定的格式制作成单一的文件，以方便用户下载和使用，例如一个测试版的操作系统、游戏等。自己的理解就是：A的东西全部合成一个文件，B把它复制了过来，我们用软件打开B，B会从一个文件变成有许多文件的另一个A。那npm官方镜像就是我们从npm服务器中把需要的包镜像储存到自己的电脑上。即使小知识点也值得花心思去弄懂鸭，每天进步一点点。!]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git新手使用总结]]></title>
    <url>%2F2019%2F01%2F06%2FGit%2F</url>
    <content type="text"><![CDATA[开始学习使用git bash惹，一边摸索一边记录下自己的学习过程。 关于GitGit是什么Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git的主要功能：版本控制关于版本控制我是这样理解的：一个文件你做了修改，得到一个新的版本，可很多时候你无法使文件回到以前的样子。所以很多人会选择把修改过后的保存到一个新文件中。久而久之文件越来越多，你很难弄清楚哪个文件做了什么修改。这个时候就需要进行版本管理。Git来对这些不同的版本进行控制。还可以很方便地查看两个不同版本之间的不同之处。 Git的工作流程 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。工作区、暂存区和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。以下是菜鸟对这些知识的解释： 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git bash使用登录申请了自己的github账号，下载git之后打开git bash。配置本机的用户名和邮箱。 123$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 本地使用创建仓库并初始化新建一个文件夹，在目录下建一个test文本，**创建test.txt的时候记得编码设置为UTF8，否则会出现乱码。右键点击git bash。test的内容随便写啦。。。。输入git init初始化仓库.git文件自动生成了，作用上文已经讲过啦，不能删噢。 文件添加和提交 $ git add 文件名.文件类型 添加我们之前创建的test文件如果一个个添加太麻烦惹，我们还有其他方法！ git add -A 提交所有变化git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 by the way! 我们可以使用git status来查看状态添加成功辣，我们先在可commit了 $ git commit -m “修改注释”提交后git log可以查看日志！ 文件修改我们添加文件后，文件开始被追踪了，这时我们可以git status看看两次的不同喔！怎么看我们修改了什么呢？ 使用$ git diff 文件名+类型 也可以查看文件的内容 $ cat 文件名这个要注意的是必须在文件夹里有那个文件你才可以查看。 如果我现在想撤销更改，执行git checkout – .然后打开文件看看，它果然复原辣！然后我们再次修改文件内容。执行添加，提交步骤。查看日志可以看到两个版本辣。 版本回退从上面的提交日志，黄色commit后面的一串数字，我们把它称为版本号吧！版本回退命令 : $ git reset –hard 版本号前7位 查看文件，已经回到第一个状态了！这是再git log查看日志，commit记录只有一个了，想了解版本回退的原理看廖雪峰老师这个解释！很清楚鸭！ https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000/ 版本恢复输入git reflog查看之前的版本，然后再次git reset –hard到需要的版本即可。 本地仓库关联远程仓库配置ssh首先生成ssh $ssh-keygen -t rsa -C “你的邮箱” 出现了这两行。这是让你输入保存这个秘钥的文件，不输入直接回车它会自动生成。回车以后让你输入push的时候需要的密码，也可以不输入直接回车，这样push的时候就没有密码。再回车。这样ssh key已经创建成功辣然后我们输入以下命令复制ssh key clip &lt; ~/.ssh/id_rsa.pub 进入github，进入Settings点击左边的ssh and GPG keys点击New SSH key，title随便起就好辣，然后把之前复制的ssh key粘贴，然后点击下面的Add SSH key。 添加成功后你的邮箱会受到信息！执行以下命令测试连接是否成功。 $ ssh -T git@github.com 连接成功这里出现了SSH警告 Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.这个警告只会出现一次，后面的操作就不会有任何警告了。 本地连接github仓库创建一个新仓库复制SSH地址，然后执行以下命令 $git remote add origin 你复制的地址 我的出现了fatal: remote origin already exists.错误，解决方案如图所示。输入git remote -v验证一下会出现你添加成功的远程仓库。如果你以后不想连接这个远程仓库了，只需要输入git remote remove +代称即可 by the way!如果你在创建 repository 的时候，加入了 README.md 或者 LICENSE ，那么 github 会拒绝你的 push 。你需要先执行 git pull origin master。 然后执行如下命令：把本地仓库上传至Github的仓库并进行关联 $ git push -u origin master 刷新github，关联成功了。 克隆远程库执行 git clone 复制的SSH地址 如果是直接clone了别人的仓库是没法push自己的修改的。你需要先fork到自己的远程仓库，然后再从自己那里clone。如果clone了一个项目，并想为这个项目贡献自己的力量，你就可以往自己的仓库推送！然后在GitHub上发起一个pull request。 本地更新远程仓库的修改因为一个项目有很多人参与，如果远程仓库改变了，你想确保自己的文件和远程的一样。执行以下代码 $ git pull origin 或者 可以输入两句“git fetch”和“git merge”$ git fetch$ git merge 以下是我学习的一些博客，感谢这些大神们无私的分享！ https://blog.csdn.net/qazwsxpcm/article/details/68946736?utm_source=blogxgwz0#t1 http://www.cnblogs.com/schaepher/p/5561193.html#function https://blog.csdn.net/qq_36667170/article/details/79085301#t0]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript编程题之检测字符串中出现次数最多的字符]]></title>
    <url>%2F2019%2F01%2F06%2Fmost%2F</url>
    <content type="text"><![CDATA[方法一： 123456789101112131415161718var str="aaaaakkkkkkssssaaggggssjjjjjsssaa";var obj=&#123;&#125;;var max,maxNum;for(var i=0;i&lt;str.length;i++)&#123; if(!obj[str[i]])&#123; obj[str[i]]=1 &#125;else&#123; obj[str[i]]++; &#125;&#125;max=0,maxNum="";for(i in obj)&#123; if(obj[i]&gt;max)&#123; max=obj[i]; maxNum=i; &#125;&#125;console.log(maxNum,max); 方法二： 123456789var str="aaaaakkkkkkssssssjjjjjsssaa";var arr=str.split("");function getMost(arr)&#123; return arr.reduce(function(prev,next)&#123; prev[next]=prev[next]+1||1; return prev; &#125;,&#123;&#125;)&#125;console.log(getMost(arr)); 如果刚看这个方法不理解，可以先熟悉一下reduce方法回掉函数各个参数的意义。reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。currentValue 必需。当前元素currentIndex 可选。当前元素的索引arr 可选。当前元素所属的数组对象。initialValue：可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。==空数组调用reduce时没有设置初始值将会报错。== 看一下以下这编程题可以帮助理解reduce方法 123456789101112131415查找数组对象中 age 大于 18 对象&#123;age: 19, name:'Jack'&#125;,&#123;age: 5, name:'Apple'&#125;,&#123;age: 12, name:'Lynn'&#125;,&#123;age: 25, name:'David'&#125;&lt;script&gt; var arr=[&#123;age: 19, name:'Jack'&#125;,&#123;age: 5, name:'Apple'&#125;,&#123;age: 12, name:'Lynn'&#125;,&#123;age: 25, name:'David'&#125;]; function adult(array)&#123; var target=array.filter(function(item) &#123; return (item.age&gt;18); &#125;); return target; &#125; console.log(adult(arr));&lt;/script&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现抽奖大转盘]]></title>
    <url>%2F2019%2F01%2F06%2FturningTable%2F</url>
    <content type="text"><![CDATA[今天试了试自己写个抽奖大转盘。先是借了两张别人的图片：下面是布局部分： 12345678&lt;div class="round"&gt; &lt;div class="box"&gt; &lt;img src="turntable.png" alt=""&gt; &lt;/div&gt; &lt;div class="btn"&gt; &lt;img src="pointer.png" alt=""&gt; &lt;/div&gt;&lt;/div&gt; css部分: 123456789101112.round&#123; position: relative; width: 450px; height: 450px;&#125;.btn&#123; position:absolute; top:50%; left: 50%; margin-top: -138px; margin-left: -94px;&#125; 接下来是JavaScript部分,并使用了css3： 12345678910111213141516171819202122232425262728293031var round=document.getElementsByClassName("round")[0]; var box=round.getElementsByClassName("box")[0].children[0]; var btn=round.getElementsByClassName("btn")[0]; btn.onclick=function()&#123; var deg=Math.floor(Math.random()*360); var num=8; var rotateDeg=num*360+deg; box.style.transform="rotate("+rotateDeg+"deg)"; box.style.transition="5s"; setTimeout("res("+deg+")",5000) &#125; function res(deg)&#123; if(deg&gt;=0&amp;&amp;deg&lt;=51)&#123; alert("免单4999"); &#125;else if(deg&gt;51&amp;&amp;deg&lt;=102)&#123; alert("免单50") &#125;else if(deg&gt;102&amp;&amp;deg&lt;=153)&#123; alert("免单10") &#125;else if(deg&gt;153&amp;&amp;deg&lt;=204)&#123; alert("免单5") &#125;else if(deg&gt;204&amp;&amp;deg&lt;=255)&#123; alert("免分期") &#125;else if(deg&gt;255&amp;&amp;deg&lt;=306)&#123; alert("提额度") &#125;else&#123; alert("未中奖") &#125; box.dataset.rotate=deg; box.style.transform="rotate("+deg+"deg)"; box.style.transition=""; &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS写斐波那契数列的几种方法]]></title>
    <url>%2F2019%2F01%2F06%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[方法1 最直观的解题思路. 123456789101112131415161718192021function fibonacci(n) &#123; var num1= 1,num2= 1,sum; for(var i = 3; i &lt;= n; i += 1) &#123; sum = num1 + num2 num1 = num2 num2 = sum &#125; return sum&#125;//稍微改进一下以上的方法function fibonaccii(n)&#123; var num1=1,num2=1,num3; var arr=[1,1]; for(var i=3;i&lt;=n;i++)&#123; num3=num1+num2; num1=num2; num2=num3; arr.push(num3); &#125; return arr;&#125; 方法2 使用递归的方法, 但是当数字过大时浏览器会出现假死现象。毕竟递归需要堆栈，数字过大内存不够。 12345678910111213 function result(n)&#123; if(n==1||n==2)&#123; return 1 &#125;; return result(n-2)+result(n-1); &#125;//同样使用递归，只不过使用了三元表达式。 var fib=function(n)&#123; return n&lt;2?n:fib(n-1)+fib(n-2); &#125;; for(var i=0;i&lt;=10;i+=1)&#123; console.log(fib(i)); &#125; 方法3 使用“记忆”方法减少运算量。在一个数组里保存我们的储存结果，储存结果隐藏在闭包中. 123456789101112131415161718192021222324252627 var fibonaci=function()&#123; var memo=[0,1]; var fib=function(n)&#123; var result=memo[n]; if(typeof result!=='number')&#123; result=fib(n-1)+fib(n-2); &#125;; return result; &#125;; return fib; &#125;();// 我们可以把这种技术推而广之//编写一个函数来帮助我们构造带记忆功能的函数. var memoizer=function(memo,formula)&#123; var recur=function(n)&#123; var result=memo[n]; if(typeof result!=='number')&#123; result=formula(recur,n); memo[n]=result; &#125;; return result; &#125;; return recur; &#125;; var fib=memoizer([0,1],function(recur,n)&#123; return recur(n-1)+recur(n-2); &#125;) 方法4 使用ES6中的generator 1234567891011function* fib(x)&#123; let a=1; let b=1; let n=0; while(n&lt;=x)&#123; yield a; [a,b]=[b,a+b]; n++; &#125;&#125;console.log(fib(5));]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
