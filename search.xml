<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生JS实现动态轮播（一）无缝轮播]]></title>
    <url>%2F2019%2F01%2F23%2FLunbo%2F</url>
    <content type="text"><![CDATA[在同学的帮助下，终于使用纯js代码实现了动态轮播，好难啊呜呜呜！学无止境加油吧！ 效果图是这样的，我们需要定义一个div，并放入三张图片，还需要左右两个按钮，以及底下三个按钮三个div。先看布局代码 12345678910&lt;div class="banner" id="banner"&gt; &lt;ul class="clear" &gt; &lt;li style="left:0" &gt;&lt;img src="k1.jpg"&gt;&lt;/li&gt; &lt;li style="left:100%" &gt;&lt;img src="k-2.jpg"&gt;&lt;/li&gt; &lt;li style="left:100%"&gt;&lt;img src="k-3.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="pageNav"&gt;&lt;/div&gt; &lt;div class="leftBtn"&gt;&lt;/div&gt; &lt;div class="rightBtn"&gt;&lt;/div&gt;&lt;/div&gt; 如何是css部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.clear:after&#123; display:block; content:""; clear:both;&#125;.banner&#123; width: 100%; position:relative; height: 390px;&#125;.banner ul&#123; width: 100%; height: 390px; list-style-type:none; overflow: hidden;&#125;.banner ul li&#123; width: 100%; position: absolute;&#125;.pageNav&#123; position: absolute; left:50%; bottom:20px; transform: translateX(-50%);&#125;.pageNav a&#123; display:inline-block; margin:0 5px; width: 20px; height: 20px; background-color:#fff; border-radius:50%; border:2px solid #000; cursor:pointer;&#125;.pageNav a.cur&#123; background-color:red;&#125;.leftBtn, .rightBtn&#123; position:absolute; top: 50%; transform:translateY(-50%); width: 40px; height: 50px; background-color:rgba(0, 0, 0, 0.5); cursor:pointer;&#125;.leftBtn&#123; left:0;&#125;.rightBtn&#123; right:0;&#125;.leftBtn:hover,.rightBtn:hover&#123; background-color:rgba(0, 0, 0, 0.8);&#125; 接下来是js部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var banner=document.getElementById("banner"); var ul=banner.getElementsByTagName("ul")[0]; var li=ul.getElementsByTagName("li"); var pageNav=banner.getElementsByClassName("pageNav")[0],leftBtn=document.getElementsByClassName("leftBtn")[0],rightBtn=document.getElementsByClassName("rightBtn")[0],n=0,index=0,timerElem=null,state=false; for(var i=0;i&lt;li.length;i++)&#123;//给图片底下添加按钮 pageA=document.createElement("a"); if(i==0)&#123; pageA.className="cur"; &#125; pageNav.appendChild(pageA); &#125; pageNav.addEventListener('click',pageNavClick,false); function pageNavClick(e)&#123; if(state)&#123; return; &#125; e=e||window.event;//兼容性考虑 for(var i=0;i&lt;li.length;i++)&#123; if(pageNav.children[i]==e.target)&#123; index=n; var offset=i-n; n=i; showBtn(n); if(offset&gt;0)&#123; showImg(-100); &#125;else&#123; showImg(100); &#125; &#125; &#125; &#125; function showBtn(index)&#123; for(var z=0;z&lt;li.length;z++)&#123; pageNav.children[z].className=""; &#125; pageNav.children[index].className="cur"; &#125; function showImg(offset)&#123; clearInterval(timerElem); var speed=offset/20; timerElem=setInterval(function()&#123; state=true; if(parseInt(li[n].style.left)==0)&#123; state=false; clearInterval(timerElem); li[n].style.left="0"; for(var l=0;l&lt;n;l++)&#123; li[l].style.left="-100%" &#125; for(var r=n+1;r&lt;li.length;r++)&#123; li[r].style.left="100%"; &#125; &#125;else&#123; li[n].style.left=parseInt(li[n].style.left)+speed+"%"; li[index].style.left=parseInt(li[index].style.left)+speed+"%"; &#125; &#125;,100) &#125; leftBtn.onclick=function()&#123; if(state)&#123; return; &#125; index=n; n--; if(n&lt;0)&#123; n=li.length-1; li[n].style.left="-100%"; &#125; showBtn(n); showImg(100); &#125; rightBtn.onclick=function()&#123; if(state)&#123; return; &#125; index=n; n++; if(n&gt;li.length- 1)&#123; n=0; li[n].style.left="100%"; &#125; showBtn(n); showImg(-100); &#125; var timer; timer=setInterval(autoLunbo,3000); function autoLunbo()&#123; rightBtn.onclick(); &#125; banner.onmouseover=function()&#123; clearInterval(timer); &#125; banner.onmouseout=function()&#123; timer=setInterval(autoLunbo,3000); &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式学习笔记]]></title>
    <url>%2F2019%2F01%2F21%2FsingleEg%2F</url>
    <content type="text"><![CDATA[今天的学习jquery组件开发时候例子使用了单例模式，所以总结了一些相关知识。 单例模式介绍首先什么是单例模式？可以这样理解：单例模式旨在保证一个类仅有一个实例，并提供一个全局的访问点。可能有人还是不太理解单例的概念，那么你可以想象生活中的一些例子。比如注册账号的时候，如果我们注册的账号已经存在，那么系统会提示我们“账号已经存在是否使用该账号登陆”，我们无法再次创建一个一模一样的账号，除非把原账号注销。这就是单例模式的生动体现。 单例模式的思路 一个类能返回一个对象的引用（并且永远是同一个）和一个获得该实例的方法（静态方法，通常使用 getInstance 名称）。那么当我们调用这个方法时，如果类持有的引用不为空就返回该引用，否者就创建该类的实例，并且将实例引用赋值给该类保持的那个引用再返回。同时将该类的构造函数定义为私有方法，避免其他函数使用该构造函数来实例化对象，只通过该类的静态方法来得到该类的唯一实例。 介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个党只能有一个书记。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 命名空间例如jQuery库的命名空间为jQuery或$。命名空间的使用是为了让代码更加整洁，在多人协作开发的情况下，不同的人定义的变量很有可能重复，此时就需要使用命名空间来约束每个人定义的变量，使相同名称的变量放在不同的命名空间中，避免相互干扰。 123456789101112131415161718// A程序员的命名空间var A = &#123; get: function(id)&#123; return document.getElementById(id); &#125; css: function(id,key,value)&#123; get(id).style[key] = value; &#125;&#125;// B程序员的命名空间var B = &#123; get: function(className)&#123; return document.getElementByClassName(className)[0]; &#125; css: function(className,key,value)&#123; get(className).style[key] = value; &#125;&#125; A、 B两个命名空间中都有一个get方法和一个css方法，用于元素获取和元素样式修改，不同的是A是通过id来获取元素，而B是通过class来获取元素，通过命名空间，可以使这些相同名称的方法共存，使用时指定相应的命名空间即可。 常量JavaScript中并没有final、static这类关键字用来定义常量，但JavaScript非常灵活，通过常量只能访问不能修改这一特点，我们可以将变量保存在函数内部，并且只提供获取变量的方法，不提供设置变量的方法，通过闭包的方式使函数执行一次并返回相应的访问方法对象，最后将这个对象放在全局空间中作为常量单例对象使用。例如： 123456789101112131415161718var Color = (function()&#123; // 私有变量 var color = &#123; &apos;RED&apos;: &apos;#ff0000&apos;, &apos;YELLOW&apos;: &apos;#ffff00&apos;, &apos;BLUE&apos;: &apos;#0000ff&apos; &#125; // 返回访问方法对象 return &#123; // 常量获取方法 get: function(name)&#123; return color[name] ? color[name] : null; &#125; &#125;&#125;)();var color = Color.get(&apos;BLUE&apos;);console.log(color); // #0000ff 实现方式实现1： 最简单的对象字面量1234567var singleton = &#123; attr : 1, method : function()&#123; return this.attr; &#125; &#125;var t1 = singleton ;var t2 = singleton ; 那么很显然的， t1 === t2 。 十分简单，并且非常使用，不足之处在于没有什么封装性，所有的属性方法都是暴露的。对于一些需要使用私有变量的情况就显得心有余而力不足了。当然在对于 this 的问题上也是有一定弊端的。 实现2：构造函数内部判断 其实和最初的JS实现有点类似，不过是将对是否已经存在该类的实例的判断放入构造函数内部。12345678910111213function Construct()&#123; // 确保只有单例 if( Construct.unique !== undefined )&#123; return Construct.unique; &#125; // 其他代码 this.name = &quot;NYF&quot;; this.age=&quot;24&quot;; Construct.unique = this;&#125;var t1 = new Construct() ;var t2 = new Construct() ; 那么也有的， t1 === t2 。 也是非常简单，无非就是提出一个属性来做判断，但是该方式也没有安全性，一旦我在外部修改了Construct的unique属性，那么单例模式也就被破坏了。 实现3 : 闭包方式12345678var single = (function()&#123; var unique; function Construct()&#123; // ... 生成单例的构造函数的代码 &#125; unique = new Constuct(); return unique;&#125;)(); 只要每次将var t1 = single; var t2 = single;即可。 与对象字面量方式类似。不过相对而言更安全一点，当然也不是绝对安全。 如果希望会用调用 single() 方式来使用，那么也只需要将内部的 return 改为 return function(){ return unique; } 以上方式也可以使用 new 的方式来进行（形式主义的赶脚）。当然这边只是给了闭包的一种例子而已，也可以在 Construct 中判断单例是否存在 等等。 各种方式在各个不同情况做好选着即可。 使用数据缓存来存储该单例，用作判断单例是否已经生成，是单例模式主要的实现思路。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS购物网站商品放大镜功能]]></title>
    <url>%2F2019%2F01%2F14%2Fzoom%2F</url>
    <content type="text"><![CDATA[首先看效果图：先是布局，左边一个小图框，包含一个鼠标移动框，右边一个放大框。 123456789&lt;div class="box"&gt; &lt;div class="small"&gt; &lt;img src="small3.jpg" alt=""&gt; &lt;div class="move"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="big"&gt; &lt;img src="big3.jpg" alt=""&gt; &lt;/div&gt;&lt;/div&gt; 写一下css 12345678910111213141516171819202122232425262728293031.small&#123; position: relative; float: left; width: 450px; height: 450px; border:1px solid #000;&#125;.small .move&#123; position: absolute; top:0; width: 300px; height: 300px; background-color: rgba(0,0,0,0.4); cursor:move; display: none;&#125;.big&#123; position: relative; float: left; width: 540px; height: 540px; margin-left: 20px; overflow: hidden; border:1px solid #000; display: none;&#125;.big img&#123; position: absolute; top:0; left: 0;&#125; js部分： 1234567891011121314151617181920212223242526272829303132333435var box=document.getElementsByClassName('box')[0],small=box.getElementsByClassName('small')[0],move=small.getElementsByClassName('move')[0],smallImg=small.getElementsByTagName('img')[0],big=box.getElementsByClassName('big')[0],bigImg=big.getElementsByTagName('img')[0];//首先把需要的元素都获取出来small.onmouseover=function()&#123; move.style.display='block'; big.style.display="block";&#125;;small.onmouseout=function()&#123; move.style.display='none'; big.style.display="none";&#125;;small.onmousemove=function(e)&#123; e=e||window.event;//兼容性考虑 var x=e.clientX-smallImg.getBoundingClientRect().left-move.offsetWidth/2; var y=e.clientY-smallImg.getBoundingClientRect().top-move.offsetHeight/2; if(x&lt;0)&#123; x=0; &#125; if(x&gt;smallImg.offsetWidth-move.offsetWidth)&#123; x=smallImg.offsetWidth-move.offsetWidth; &#125; if(y&lt;0)&#123; y=0; &#125; if(y&gt;smallImg.offsetHeight-move.offsetHeight)&#123; y=smallImg.offsetHeight-move.offsetHeight; &#125; move.style.left=x+"px"; move.style.top=y+"px"; //实现左边move块跟随鼠标移动的代码 var scale=bigImg.offsetWidth/smallImg.offsetWidth; //按照比例放大 bigImg.style.left='-'+x*scale+'px'; //因为图片是需要左移和上移的所以要加负号 bigImg.style.top='-'+y*scale+'px';&#125; 放大镜效果就实现啦！]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery $.extend()使用方法总结]]></title>
    <url>%2F2019%2F01%2F14%2FjQuery-extend()%2F</url>
    <content type="text"><![CDATA[extend能实现的功能将一个或多个对象的内容合并到目标对象。语法： $.extend( target [, object1 ] [, objectN ] )；$.extend( [deep ], target, object1 [, objectN ] ) deep： 可选。 Boolean类型 指示是否深度合并对象，默认为false。如果该值为true，且多个对象的某个同名属性也都是对象，则该”属性对象”的属性也将进行合并。 target： Object类型 目标对象，其他对象的成员属性将被附加到该对象上。 object1：可选。 Object类型 第一个被合并的对象。 objectN：可选。 Object类型 第N个被合并的对象。注意： 如果只为$.extend()指定了一个参数，则意味着参数target被省略。此时，target就是jQuery对象本身。通过这种方式，我们可以为全局对象jQuery添加新的函数。 如果多个对象具有相同的属性，则后者会覆盖前者的属性值。 举例： $.extend(object1, object2); //object2 合并到 object1 中 多传几个参数： 123456789101112131415161718192021function test(target,obj1,obj2,obj3)&#123; $.extend(target,obj1,obj2,obj3); return target;&#125;;var target=&#123; name:&apos;jack&apos;, sex:&apos;male&apos;&#125;;var obj1=&#123; name:&quot;rose&quot;, age:20&#125;;var obj2=&#123; sex:&apos;female&apos;, age:24&#125;;var obj3=&#123; bb:&apos;you jump i jump&apos;&#125;;console.log(test(target,obj1,obj2,obj3));//Object &#123; name: &quot;rose&quot;, sex: &quot;female&quot;, age: 24, bb: &quot;you jump i jump&quot; &#125; 这里我们传入了4个参数，然后返回第一个参数的值。从运行的得到结果我们可以看到，属性值永远是最后一个属性的值。我们稍微修改一部分代码： 123 var res=$.extend(target,obj1,obj2,obj3); return res;结果返回依然是Object &#123; name: &quot;rose&quot;, sex: &quot;female&quot;, age: 24, bb: &quot;you jump i jump&quot; &#125; 所以$.extend()的返回值是第一个参数的值。如果我们不想修改参数的值，我们可以把传入一个空对象： $.extend({ },target,obj1,obj2,obj3); 为jQuery开发插件提供方法如果只有一个参数提供给$.extend()，在这种情况下，jQuery对象本身被默认为目标对象。这样，我们可以在jQuery的命名空间下添加新的功能。这对于插件开发者希望向 jQuery 中添加新函数时是很有用的。 jQuery.extend(object)： 为jQuery类本身添加类方法，可以理解为添加静态方法。 12345678$.extend(&#123; hello:function()&#123; return &quot;hello&quot;+this._name; &#125;, _name:&apos;jack&apos;&#125;)console.log($._name,$.hello());//jack hellojack jQuery.fn.extend(object);给jQuery对象添加方法。。jQuery类的实例才可以调用这个“成员函数”。为什么呢我们先看： 1234jQuery.fn = jQuery.prototype = &#123; init: function( selector, context ) &#123;//….//……&#125;; ．ｆｎ属性是在原型上的，所以只有实例化出来的jQuery可以调用你ｅｘｔｅｎｄ里想添加的方法。 比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做： 123456789$.fn.extend(&#123; alertWhileClick: function() &#123; $(this).click(function() &#123; alert($(this).val()); &#125;); &#125;&#125;);//$(&quot;#input1&quot;)是jQuery的实例，调用这个扩展方法$(&quot;#input1&quot;).alertWhileClick();]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现抽奖大转盘]]></title>
    <url>%2F2019%2F01%2F11%2Fstar_js%2F</url>
    <content type="text"><![CDATA[因为用到自定义字体，我首先到阿里巴巴矢量图标库下载了自己喜欢的星星样式。需要一个空心星星，一个实心星星。 按照使用方法，如下图所示引入这些文件。 接下来是布局，三行评价，都是一样的样式，那就用一个无序列表吧！ 1234567891011121314151617181920212223242526272829&lt;ul&gt; &lt;li class="goods"&gt; 宝贝与描述相符： &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;/li&gt; &lt;li class="att"&gt; 卖家的服务态度： &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;/li&gt; &lt;li class="trans"&gt; 物流服务的质量： &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;i class="star"&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;/li&gt;&lt;/ul&gt; 给star类加了一个伪类用来显示星星图标： 12345678910111213141516 .star:after&#123; font-family: 'Hui-iconfont'; font-size:25px; font-style:normal; content:"\e702"; vertical-align:middle;/*使文字和图标对齐*/ color:#eee; &#125;下面这是实心星星的： .current:after&#123; font-family: 'Hui-iconfont'; font-size:25px; font-style:normal; content:"\e6ff"; vertical-align:middle; &#125; 布局完是这样的：下面开始写js. 1234567891011121314151617181920212223242526272829303132333435363738function comment(liName,content)&#123; var li=document.getElementsByClassName(liName)[0]; var star=li.getElementsByTagName("i"); var currentClick=0,num=0; for(var i=1;i&lt;=star.length;i++)&#123; star[i-1].index=i; star[i-1].onmouseover=function()&#123; show(this.index); &#125; star[i-1].onmouseout=function()&#123; //选择i=1；就是为了把0让给这一步，鼠标移开不显示实星星。 show(0); &#125; star[i-1].onclick=function()&#123; currentClick=this.index; show(currentClick); &#125; &#125; function show(index)&#123; //当点击后，又经过又离开，传递参数0；但短路语句直接返回currentClick,以此保证点击之后再经过也不改变。 num=index||currentClick; for(var j=0;j&lt;star.length;j++)&#123; star[j].className=(j&lt;num)?'current':'star'; if(num==1||num==2)&#123; star[j].style.color="#666" &#125; else if(num==3||num==4)&#123; star[j].style.color="orange"; &#125; else&#123; star[j].style.color="red"; &#125; &#125; li.getElementsByTagName("em")[0].innerText=num&gt;0?content[num-1]:""; &#125;&#125;var arr=["一分 失望","两分 不满","三分 一般","四分 满意","五分 惊喜"];comment("goods",arr);comment("att",arr);comment("trans",arr) 就可以实现基本的效果啦！]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础之Dom篇总结]]></title>
    <url>%2F2019%2F01%2F08%2FjQuery_Dom%2F</url>
    <content type="text"><![CDATA[dom小知识点很多，总是过段时间又忘了，这次做个总结吧。 Dom节点的创建jQuery节点创建常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来。创建元素节点： 1234567$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)创建文本节点：$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;)创建属性节点：$(&quot;&lt;div id=&apos;test&apos; class=&apos;aaron&apos;&gt;我是文本节点&lt;/div&gt;&quot;) Dom节点的插入内部插入.append()前面是被插入的对象，后面是要在对象内插入的元素内容.appendTo()前面是要插入的元素内容，而后面是被插入的对象.prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素.prependTo()方法前面是要插入的元素内容，后面是被插入的对象，插到之前。1234567891011121314 例子 &lt;h2&gt;通过append与appendTo添加元素&lt;/h2&gt; &lt;button id="btn1"&gt;点击通过jQuery的append添加元素&lt;/button&gt; &lt;button id="btn2"&gt;点击通过jQuery的appendTo添加元素&lt;/button&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;script&gt; $("#btn1").on('click',function()&#123; $('.content').append($('&lt;div class="append"&gt;通过append方法添加的元素&lt;/div&gt;')) // $('.content').prepend($('&lt;p&gt;prepend方法插入的元素！在前面哦！&lt;/p&gt;')) &#125;) $('#btn2').on('click',function()&#123; $('&lt;div class="appendTo"&gt;通过appendTo方法添加的元素&lt;/div&gt;').appendTo($('.content')) &#125;)&lt;/script&gt; 外部插入.before():在选中元素后插入参数所指定的内容，作为其兄弟节点.after():在选中元素前插入参数所指定的内容，作为其兄弟节点 before与after都是用来对相对选中元素外部增加相邻的兄弟节点2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面2个方法都支持多个参数传递after(div1,div2,….) insertAfter()与insertBefore()insertBefore()和before的效果是一样的，只不过使用方式不一样。insertBefore():插入的内容在前，括号里是要插入的节点。不支持多参数！ 123456789101112131415例子&lt;h2&gt;通过insertBefore与insertAfter添加元素&lt;/h2&gt; &lt;button id="bt1"&gt;点击通过jQuery的insertBefore添加元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的insertAfter添加元素&lt;/button&gt; &lt;div class="aaron"&gt; &lt;p class="test1"&gt;测试insertBefore,不支持多参数&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p class="test2"&gt;测试insertAfter,不支持多参数&lt;/p&gt; &lt;/div&gt;&lt;script&gt; $('#bt1').on('click',function()&#123; $('&lt;p style="color:red"&gt;测试insertBefore方法增加&lt;/p&gt;', '&lt;p style="color:red"&gt;多参数&lt;/p&gt;').insertBefore($(".test1")); &#125;)&lt;/script&gt; Dom节点的删除empty():顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了指定元素中的所有子节点。 remove()会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。remove可以传递一个选择器表达式用来过滤匹配元素，可以选择性的删除指定的节点 例如： 123$(&quot;p&quot;).remove(&quot;:contains(&apos;3&apos;)&quot;) 移除所有元素中包含3文本的 此代码也可以写为： $(&quot;p&quot;).filter(&quot;:contains(&apos;3&apos;)&quot;).remove() 保留数据的删除操作detach()： 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。 $(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据。 Dom节点的复制与替换 clone（）：.clone() 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。.clone()是浅拷贝。 .clone(true)是深拷贝。复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。.clone()是浅拷贝。 .clone(true)是深拷贝。 replaceWith(), .replaceAll( target ):.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合.replaceWith( newContent )：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合.replaceAll( target ) ：用集合的匹配元素替换每个目标元素.replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序.replaceWith（）方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用。返回的是Jquery对象引用的是替换前的节点。 wrap()方法:.wrap( wrappingElement )：在集合中匹配的每个元素周围包裹.wrap( function ) ：一个回调函数，返回用于包裹匹配元素的HTML 内容或 jQuery 对象。 unwrap()方法:作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。 wrapAll()方法:wrap是针对单个dom元素处理，如果要将集合中的元素用其他元素包裹起来，也就是给他们增加一个父元素，针对这样的处理，JQuery提供了一个wrapAll方法.wrapAll( wrappingElement )：给集合中匹配的元素增加一个外面包裹HTML结构.wrapAll( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。 .wrapInner( wrappingElement )：.wrapInner( wrappingElement )： 给集合中匹配的元素的内部，增加包裹的HTML结构给集合中匹配的元素的内部，增加包裹的HTML结构将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素。.wrapInner( function ) ：允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容注意： 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。遍历后代：children() 方法返回被选元素的所有直接子元素。该方法只会向下一级对DOM 树进行遍历。.children()方法选择性地接受同一类型选择器表达式例如：$(“div”).children(“.selected”)因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签)。例子： 12var $spans = $(&apos;span&apos;);$(&quot;p&quot;).find($spans).css(&apos;color&apos;, &apos;red&apos;); 祖先：parent() 方法返回被选元素的直接父元素。该方法只会向上一级对 DOM 树进行遍历。 parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。可以使用可选参数来过滤对祖先元素的搜索。 parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。 closest()：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素树上逐级向上级元素匹配，并返回最先匹配的祖先元素。$(“div”).closet(“li’) 在div元素中往上查找所有的li元素 .parents()和.closest()的区别： 1.起始位置不同：.closest开始于当前元素 .parents开始于父元素 2.遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 3.结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 同胞：next() 方法返回被选元素的下一个同胞元素。该方法只返回一个元素。选择性地接受同一类型选择器表达式prev() 查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合.选择性地接受同一类型选择器表达式nextAll() 返回被选元素的所有跟随的同胞元素。nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。siblings() 方法返回被选元素的所有同胞元素。选择性地接受同一类型选择器表达式 add():将元素添加到匹配的元素集合中，.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。 123456each()： $(&quot;li&quot;).each(function(index, element) &#123; index 索引 0,1 element是对应的li节点 li,li this 指向的是li &#125;) each是一个for循环的包装迭代器 each通过回调的方式处理，并且会有2个固定的实参，索引与元素 each回调方法中的this指向当前迭代的dom元素例子： 12345678910111213141516 &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;p&gt;6&lt;/p&gt;&lt;script&gt; $('p').each(function(index,ele)&#123; $(this).css('color','red'); &#125;); $('p').each(function(index,ele)&#123; if(index %2)&#123; $(this).css('color','blue'); &#125;; &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是SDK什么是CDN]]></title>
    <url>%2F2019%2F01%2F07%2FCDN%2F</url>
    <content type="text"><![CDATA[今天的学习过程中碰到了Sdk，cdn，关于它们一直没有清楚的概念。好吧对于我来说要了解好CDN得花点功夫了- -！不懂不要紧，加油学吧！ 什么是SDK软件开发工具包（Software Development Kit，即SDK）一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。 软件开发工具包，只是简单的为某个程序设计语言提供应用程序接口的一些文件，但也可能包括能与某种嵌入式系统通讯的复杂的硬件。 SDK通常包含许可证，这些许可证使它们不适合构建旨在根据不兼容许可证开发的软件。例如，专有SDK通常与自由软件开发不兼容，而GPL许可的SDK可能与专有软件开发不兼容，所有这些都特别是出于法律原因。但是，根据GNU宽通用公共许可证（LGPL）构建的SDK通常对于专有开发是安全的。 SDK是一系列程序接口，文档，开发工具的集合。sdk即单单不是一个开发工具，也不是一个程序。一个完整的SDK应该包括以下内容： （1）接口文件和库文件接口文件和库文件就是API，将底层的代码进行封装保护，提供给用户一个调用底层代码的接口； （2）帮助文档帮助文档解释接口文件和库文件功能，以及介绍相关的开发工具，操作示例等等； （3）开发示例开发示例就是做出来的一个DEMO展示，也要包括源代码； （4）实用工具。 实用工具是用来协助用户进行二次开发的工具，比如二次开发向导、API 搜索工具、软件打包工具等。 CDN什么是CDNCDN的全称是Content Delivery Network，即内容分发网络。 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 基本原理CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 使用CDN的好处CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。因此，有如下优点： 通过提高网站响应速度，改善用户体验，增强用户满意度和粘合度; 轻松应对突发流量，随时展开网络推广; 有效抵御洪水式网络攻击，使网站永不宕机; 减少源站点负载，节省网站分布式架构的支出成本和运维成本。 基础架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成： 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。 CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。 用户向CDN的全局负载均衡设备发起内容URL访问请求。 CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。 全局负载均衡设备把服务器的IP地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。哪些情况推荐使用CDN？一般来说以资讯、内容等为主的网站，具有一定访问体量的网站资讯网站、政府机构网站、行业平台网站、商城等以动态内容为主的网站论坛、博客、交友、SNS、网络游戏、搜索/查询、金融等。提供http下载的网站软件开发商、内容服务提供商、网络游戏运行商、源码下载等有大量流媒体点播应用的网站拥有视频点播平台的电信运营商、内容服务提供商、体育频道、宽频频道、在线教育、视频博客等这个大神关于CDN的解释真的很通俗易懂！侵权删！ https://www.zhihu.com/question/36514327]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>sdk</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高级之运动系列（匀速运动/缓冲运动/弹性运动）]]></title>
    <url>%2F2019%2F01%2F06%2FJS_moves%2F</url>
    <content type="text"><![CDATA[匀速运动鼠标经过，匀速运动开始css部分12345678910111213141516171819202122232425*&#123; margin: 0; padding: 0;&#125;.box&#123; position:relative; width:150px; height:150px; background-color: green; top:300px; left:-150px;&#125;.box span&#123; position:absolute; right:-20px; display:block; width:20px; background-color: red; top:50%; -webkit-transform: translateY(-50%); -moz-transform: translateY(-50%); -ms-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 布局123&lt;div class="box"&gt; &lt;span&gt;匀速&lt;/span&gt;&lt;/div&gt; js代码12345678910111213141516171819202122232425262728window.onload=function()&#123; var box=document.getElementsByClassName("box")[0]; box.onmouseover=function()&#123; startMove(box,0); &#125; box.onmouseout=function()&#123; startMove(box,-150); &#125;&#125;var timer=null;function startMove(obj,target)&#123; var speed=0; clearInterval(timer); timer=setInterval(function()&#123; if(obj.offsetLeft&lt;target)&#123; speed=10; &#125;else&#123; speed=-10; &#125; if(obj.offsetLeft==target)&#123; clearInterval(timer); &#125;else&#123; obj.style.left=obj.offsetLeft+speed+"px"; &#125; &#125;,30);&#125; 简单缓冲运动并回到原点布局部分，嘿嘿以简单为主。1234&lt;div class="box"&gt;&lt;/div&gt;&lt;input type="button" name="" value="开始"&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;input type="button" name="" value="回到原点"&gt; css部分12345678910111213141516171819body&#123; padding: 0; margin: 0;&#125;.box&#123; position:absolute; top:40px; width: 100px; height: 100px; background-color:red;&#125;.line&#123; position:absolute; left:700px; top:0; width: 5px; height: 200px; background-color:#000;&#125; js代码12345678910111213141516171819202122232425262728293031323334353637var btn=document.getElementsByTagName("input")[0]; var box=document.getElementsByClassName("box")[0]; var back=document.getElementsByTagName("input")[1]; window.onload=function()&#123; var timer=null; btn.onclick=function()&#123; startMove(box,700); &#125; //缓冲运动部分 function startMove(elem,target)&#123; clearTimeout(timer); timer=setInterval(function()&#123; var speed=(target-elem.offsetLeft)/10; speed=speed&gt;0?Math.ceil((target-elem.offsetLeft)/10):Math.floor((target-elem.offsetLeft)/10); if(target==elem.offsetLeft)&#123; clearTimeout(timer); &#125;else&#123; elem.style.left=elem.offsetLeft+speed+"px"; &#125; &#125;,100) &#125; back.onclick=function()&#123; startMove(box,0); &#125; //回到原点部分 function backMove(elem,target)&#123; clearTimeout(timer); timer=setInterval(function()&#123; var speed=Math.floor((target-elem.offsetLeft)/10); if(target==elem.offsetLeft)&#123; clearTimeout(timer); &#125;else&#123; elem.style.left=elem.offsetLeft+speed+"px"; &#125; &#125;,100) &#125; &#125; 弹性运动一个运动的盒子，一个开始的按钮，一条终点线.，我设置这条线的原因是方便看出效果，也可以不设啦。123&lt;div class="box"&gt;&lt;/div&gt;&lt;input type="button" name="" value="开始"&gt;&lt;div class="line"&gt;&lt;/div&gt; javaScript代码如下：12345678910111213141516171819202122window.onload=function()&#123; var btn=document.getElementsByTagName("input")[0]; var box=document.getElementsByClassName("box")[0]; btn.onclick=function()&#123; startMove(box,700); &#125; var timer=null; function startMove(elem,target)&#123; var speed=0; timer=setInterval(function()&#123; speed+=(target-elem.offsetLeft)/8; speed*=0.7; //我觉得0.7的效果好一点 if(Math.abs(speed)&lt;1&amp;&amp;Math.abs(elem.offsetLeft-target)&lt;1)&#123; clearTimeout(timer); elem.style.left=target+"px";//回到终点位置 &#125;else&#123; elem.style.left=elem.offsetLeft+speed+"px"; &#125; &#125;,100) &#125; &#125; 为了使刚好在终点线的位置做弹性运动，传入参数target就是终点线距离盒子的位置。css部分123456789101112131415.box&#123; position:absolute; top:40px; width: 100px; height: 100px; background-color:red;&#125;.line&#123; position:absolute; left:700px; top:0; width: 5px; height: 200px; background-color:#000;&#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习镜像概念]]></title>
    <url>%2F2019%2F01%2F06%2FMirroring%2F</url>
    <content type="text"><![CDATA[在自学Node.js过程中，看到有说国内直接使用 npm 的官方镜像是非常慢的，推荐使用淘宝 NPM 镜像。由于是半路出家没有很好的计算机基础知识，并不清楚镜像的概念。镜像（Mirroring）是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。镜像是一种文件存储形式，可以把许多文件做成一个镜像文件。所谓镜像文件其实和ZIP压缩包类似，它将特定的一系列文件按照一定的格式制作成单一的文件，以方便用户下载和使用，例如一个测试版的操作系统、游戏等。自己的理解就是：A的东西全部合成一个文件，B把它复制了过来，我们用软件打开B，B会从一个文件变成有许多文件的另一个A。那npm官方镜像就是我们从npm服务器中把需要的包镜像储存到自己的电脑上。即使小知识点也值得花心思去弄懂鸭，每天进步一点点。!]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git新手使用总结]]></title>
    <url>%2F2019%2F01%2F06%2FGit%2F</url>
    <content type="text"><![CDATA[开始学习使用git bash惹，一边摸索一边记录下自己的学习过程。 关于GitGit是什么Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git的主要功能：版本控制关于版本控制我是这样理解的：一个文件你做了修改，得到一个新的版本，可很多时候你无法使文件回到以前的样子。所以很多人会选择把修改过后的保存到一个新文件中。久而久之文件越来越多，你很难弄清楚哪个文件做了什么修改。这个时候就需要进行版本管理。Git来对这些不同的版本进行控制。还可以很方便地查看两个不同版本之间的不同之处。 Git的工作流程 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。工作区、暂存区和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。以下是菜鸟对这些知识的解释： 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git bash使用登录申请了自己的github账号，下载git之后打开git bash。配置本机的用户名和邮箱。 123$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 本地使用创建仓库并初始化新建一个文件夹，在目录下建一个test文本，**创建test.txt的时候记得编码设置为UTF8，否则会出现乱码。右键点击git bash。test的内容随便写啦。。。。输入git init初始化仓库.git文件自动生成了，作用上文已经讲过啦，不能删噢。 文件添加和提交 $ git add 文件名.文件类型 添加我们之前创建的test文件如果一个个添加太麻烦惹，我们还有其他方法！ git add -A 提交所有变化git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 by the way! 我们可以使用git status来查看状态添加成功辣，我们先在可commit了 $ git commit -m “修改注释”提交后git log可以查看日志！ 文件修改我们添加文件后，文件开始被追踪了，这时我们可以git status看看两次的不同喔！怎么看我们修改了什么呢？ 使用$ git diff 文件名+类型 也可以查看文件的内容 $ cat 文件名这个要注意的是必须在文件夹里有那个文件你才可以查看。 如果我现在想撤销更改，执行git checkout – .然后打开文件看看，它果然复原辣！然后我们再次修改文件内容。执行添加，提交步骤。查看日志可以看到两个版本辣。 版本回退从上面的提交日志，黄色commit后面的一串数字，我们把它称为版本号吧！版本回退命令 : $ git reset –hard 版本号前7位 查看文件，已经回到第一个状态了！这是再git log查看日志，commit记录只有一个了，想了解版本回退的原理看廖雪峰老师这个解释！很清楚鸭！ https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000/ 版本恢复输入git reflog查看之前的版本，然后再次git reset –hard到需要的版本即可。 本地仓库关联远程仓库配置ssh首先生成ssh $ssh-keygen -t rsa -C “你的邮箱” 出现了这两行。这是让你输入保存这个秘钥的文件，不输入直接回车它会自动生成。回车以后让你输入push的时候需要的密码，也可以不输入直接回车，这样push的时候就没有密码。再回车。这样ssh key已经创建成功辣然后我们输入以下命令复制ssh key clip &lt; ~/.ssh/id_rsa.pub 进入github，进入Settings点击左边的ssh and GPG keys点击New SSH key，title随便起就好辣，然后把之前复制的ssh key粘贴，然后点击下面的Add SSH key。 添加成功后你的邮箱会受到信息！执行以下命令测试连接是否成功。 $ ssh -T git@github.com 连接成功这里出现了SSH警告 Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.这个警告只会出现一次，后面的操作就不会有任何警告了。 本地连接github仓库创建一个新仓库复制SSH地址，然后执行以下命令 $git remote add origin 你复制的地址 我的出现了fatal: remote origin already exists.错误，解决方案如图所示。输入git remote -v验证一下会出现你添加成功的远程仓库。如果你以后不想连接这个远程仓库了，只需要输入git remote remove +代称即可 by the way!如果你在创建 repository 的时候，加入了 README.md 或者 LICENSE ，那么 github 会拒绝你的 push 。你需要先执行 git pull origin master。 然后执行如下命令：把本地仓库上传至Github的仓库并进行关联 $ git push -u origin master 刷新github，关联成功了。 克隆远程库执行 git clone 复制的SSH地址 如果是直接clone了别人的仓库是没法push自己的修改的。你需要先fork到自己的远程仓库，然后再从自己那里clone。如果clone了一个项目，并想为这个项目贡献自己的力量，你就可以往自己的仓库推送！然后在GitHub上发起一个pull request。 本地更新远程仓库的修改因为一个项目有很多人参与，如果远程仓库改变了，你想确保自己的文件和远程的一样。执行以下代码 $ git pull origin 或者 可以输入两句“git fetch”和“git merge”$ git fetch$ git merge 以下是我学习的一些博客，感谢这些大神们无私的分享！ https://blog.csdn.net/qazwsxpcm/article/details/68946736?utm_source=blogxgwz0#t1 http://www.cnblogs.com/schaepher/p/5561193.html#function https://blog.csdn.net/qq_36667170/article/details/79085301#t0]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript编程题之检测字符串中出现次数最多的字符]]></title>
    <url>%2F2019%2F01%2F06%2Fmost%2F</url>
    <content type="text"><![CDATA[方法一： 123456789101112131415161718var str="aaaaakkkkkkssssaaggggssjjjjjsssaa";var obj=&#123;&#125;;var max,maxNum;for(var i=0;i&lt;str.length;i++)&#123; if(!obj[str[i]])&#123; obj[str[i]]=1 &#125;else&#123; obj[str[i]]++; &#125;&#125;max=0,maxNum="";for(i in obj)&#123; if(obj[i]&gt;max)&#123; max=obj[i]; maxNum=i; &#125;&#125;console.log(maxNum,max); 方法二： 123456789var str="aaaaakkkkkkssssssjjjjjsssaa";var arr=str.split("");function getMost(arr)&#123; return arr.reduce(function(prev,next)&#123; prev[next]=prev[next]+1||1; return prev; &#125;,&#123;&#125;)&#125;console.log(getMost(arr)); 如果刚看这个方法不理解，可以先熟悉一下reduce方法回掉函数各个参数的意义。reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。currentValue 必需。当前元素currentIndex 可选。当前元素的索引arr 可选。当前元素所属的数组对象。initialValue：可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。==空数组调用reduce时没有设置初始值将会报错。== 看一下以下这编程题可以帮助理解reduce方法 123456789101112131415查找数组对象中 age 大于 18 对象&#123;age: 19, name:'Jack'&#125;,&#123;age: 5, name:'Apple'&#125;,&#123;age: 12, name:'Lynn'&#125;,&#123;age: 25, name:'David'&#125;&lt;script&gt; var arr=[&#123;age: 19, name:'Jack'&#125;,&#123;age: 5, name:'Apple'&#125;,&#123;age: 12, name:'Lynn'&#125;,&#123;age: 25, name:'David'&#125;]; function adult(array)&#123; var target=array.filter(function(item) &#123; return (item.age&gt;18); &#125;); return target; &#125; console.log(adult(arr));&lt;/script&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现抽奖大转盘]]></title>
    <url>%2F2019%2F01%2F06%2FturningTable%2F</url>
    <content type="text"><![CDATA[今天试了试自己写个抽奖大转盘。先是借了两张别人的图片：下面是布局部分： 12345678&lt;div class="round"&gt; &lt;div class="box"&gt; &lt;img src="turntable.png" alt=""&gt; &lt;/div&gt; &lt;div class="btn"&gt; &lt;img src="pointer.png" alt=""&gt; &lt;/div&gt;&lt;/div&gt; css部分: 123456789101112.round&#123; position: relative; width: 450px; height: 450px;&#125;.btn&#123; position:absolute; top:50%; left: 50%; margin-top: -138px; margin-left: -94px;&#125; 接下来是JavaScript部分,并使用了css3： 12345678910111213141516171819202122232425262728293031var round=document.getElementsByClassName("round")[0]; var box=round.getElementsByClassName("box")[0].children[0]; var btn=round.getElementsByClassName("btn")[0]; btn.onclick=function()&#123; var deg=Math.floor(Math.random()*360); var num=8; var rotateDeg=num*360+deg; box.style.transform="rotate("+rotateDeg+"deg)"; box.style.transition="5s"; setTimeout("res("+deg+")",5000) &#125; function res(deg)&#123; if(deg&gt;=0&amp;&amp;deg&lt;=51)&#123; alert("免单4999"); &#125;else if(deg&gt;51&amp;&amp;deg&lt;=102)&#123; alert("免单50") &#125;else if(deg&gt;102&amp;&amp;deg&lt;=153)&#123; alert("免单10") &#125;else if(deg&gt;153&amp;&amp;deg&lt;=204)&#123; alert("免单5") &#125;else if(deg&gt;204&amp;&amp;deg&lt;=255)&#123; alert("免分期") &#125;else if(deg&gt;255&amp;&amp;deg&lt;=306)&#123; alert("提额度") &#125;else&#123; alert("未中奖") &#125; box.dataset.rotate=deg; box.style.transform="rotate("+deg+"deg)"; box.style.transition=""; &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS写斐波那契数列的几种方法]]></title>
    <url>%2F2019%2F01%2F06%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[方法1 最直观的解题思路. 123456789101112131415161718192021function fibonacci(n) &#123; var num1= 1,num2= 1,sum; for(var i = 3; i &lt;= n; i += 1) &#123; sum = num1 + num2 num1 = num2 num2 = sum &#125; return sum&#125;//稍微改进一下以上的方法function fibonaccii(n)&#123; var num1=1,num2=1,num3; var arr=[1,1]; for(var i=3;i&lt;=n;i++)&#123; num3=num1+num2; num1=num2; num2=num3; arr.push(num3); &#125; return arr;&#125; 方法2 使用递归的方法, 但是当数字过大时浏览器会出现假死现象。毕竟递归需要堆栈，数字过大内存不够。 12345678910111213 function result(n)&#123; if(n==1||n==2)&#123; return 1 &#125;; return result(n-2)+result(n-1); &#125;//同样使用递归，只不过使用了三元表达式。 var fib=function(n)&#123; return n&lt;2?n:fib(n-1)+fib(n-2); &#125;; for(var i=0;i&lt;=10;i+=1)&#123; console.log(fib(i)); &#125; 方法3 使用“记忆”方法减少运算量。在一个数组里保存我们的储存结果，储存结果隐藏在闭包中. 123456789101112131415161718192021222324252627 var fibonaci=function()&#123; var memo=[0,1]; var fib=function(n)&#123; var result=memo[n]; if(typeof result!=='number')&#123; result=fib(n-1)+fib(n-2); &#125;; return result; &#125;; return fib; &#125;();// 我们可以把这种技术推而广之//编写一个函数来帮助我们构造带记忆功能的函数. var memoizer=function(memo,formula)&#123; var recur=function(n)&#123; var result=memo[n]; if(typeof result!=='number')&#123; result=formula(recur,n); memo[n]=result; &#125;; return result; &#125;; return recur; &#125;; var fib=memoizer([0,1],function(recur,n)&#123; return recur(n-1)+recur(n-2); &#125;) 方法4 使用ES6中的generator 1234567891011function* fib(x)&#123; let a=1; let b=1; let n=0; while(n&lt;=x)&#123; yield a; [a,b]=[b,a+b]; n++; &#125;&#125;console.log(fib(5));]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
